"""
VirusTotal API Scanner - Wrapper class for VirusTotal API v3
"""
import os
import hashlib
import requests
import time
from typing import Optional, Dict, Any, Tuple


class VirusTotalScanner:
    """VirusTotal API wrapper for file and URL scanning"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://www.virustotal.com/api/v3"
        self.headers = {
            "x-apikey": api_key,
            "Accept": "application/json"
        }
    
    def test_connection(self) -> Tuple[bool, str]:
        """Test if the API key is valid"""
        if not self.api_key:
            return False, "API key not configured"
        
        try:
            response = requests.get(
                f"{self.base_url}/users/current",
                headers=self.headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return True, "API connected successfully"
            elif response.status_code == 401:
                return False, "Invalid API key"
            else:
                return False, f"Unexpected response: {response.status_code}"
        except requests.exceptions.RequestException as e:
            return False, f"Connection error: {str(e)}"
    
    @staticmethod
    def calculate_hash(file_path: str) -> str:
        """Calculate SHA-256 hash of a file"""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    
    def check_file_report(self, file_hash: str) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """Check if file already exists in VirusTotal database"""
        try:
            response = requests.get(
                f"{self.base_url}/files/{file_hash}",
                headers=self.headers,
                timeout=15
            )
            
            if response.status_code == 200:
                result = response.json()
                data = result.get('data', {})
                attributes = data.get('attributes', {})
                stats = attributes.get('last_analysis_stats', {})
                
                return True, {
                    'found': True,
                    'stats': stats,
                    'sha256': attributes.get('sha256', file_hash),
                    'file_name': attributes.get('meaningful_name', 'Unknown'),
                    'vt_link': f"https://www.virustotal.com/gui/file/{file_hash}"
                }
            elif response.status_code == 404:
                return True, {'found': False}
            else:
                return False, {'error': f"Status code: {response.status_code}"}
        except requests.exceptions.RequestException as e:
            return False, {'error': str(e)}
    
    def upload_file(self, file_path: str) -> Tuple[bool, Dict[str, Any]]:
        """Upload a file to VirusTotal for scanning"""
        if not os.path.exists(file_path):
            return False, {'error': 'File not found'}
        
        file_size = os.path.getsize(file_path)
        
        # Check file size limit (32MB for regular endpoint)
        if file_size > 32 * 1024 * 1024:
            return False, {'error': 'File too large. Maximum size is 32MB.'}
        
        try:
            with open(file_path, 'rb') as f:
                files = {"file": (os.path.basename(file_path), f)}
                response = requests.post(
                    f"{self.base_url}/files",
                    headers=self.headers,
                    files=files,
                    timeout=120
                )
            
            if response.status_code == 200:
                result = response.json()
                data = result.get('data', {})
                analysis_id = data.get('id')
                
                return True, {
                    'analysis_id': analysis_id,
                    'file_size': file_size
                }
            else:
                return False, {'error': f"Upload failed: {response.status_code} - {response.text}"}
        except requests.exceptions.RequestException as e:
            return False, {'error': f"Upload error: {str(e)}"}
    
    def get_analysis_report(self, analysis_id: str) -> Tuple[bool, Dict[str, Any]]:
        """Get the analysis report for a submitted file or URL"""
        try:
            response = requests.get(
                f"{self.base_url}/analyses/{analysis_id}",
                headers=self.headers,
                timeout=15
            )
            
            if response.status_code == 200:
                result = response.json()
                data = result.get('data', {})
                attributes = data.get('attributes', {})
                stats = attributes.get('stats', {})
                status = attributes.get('status', 'queued')
                
                return True, {
                    'status': status,
                    'stats': stats,
                    'results': attributes.get('results', {})
                }
            else:
                return False, {'error': f"Status code: {response.status_code}"}
        except requests.exceptions.RequestException as e:
            return False, {'error': str(e)}
    
    def scan_url(self, url: str) -> Tuple[bool, Dict[str, Any]]:
        """Submit a URL for scanning"""
        try:
            response = requests.post(
                f"{self.base_url}/urls",
                headers=self.headers,
                data={"url": url},
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                data = result.get('data', {})
                analysis_id = data.get('id')
                
                # URL ID is base64 encoded
                import base64
                url_id = base64.urlsafe_b64encode(url.encode()).decode().strip("=")
                
                return True, {
                    'analysis_id': analysis_id,
                    'url_id': url_id,
                    'vt_link': f"https://www.virustotal.com/gui/url/{url_id}"
                }
            else:
                return False, {'error': f"Scan failed: {response.status_code} - {response.text}"}
        except requests.exceptions.RequestException as e:
            return False, {'error': f"Scan error: {str(e)}"}
    
    def get_url_report(self, url_id: str) -> Tuple[bool, Dict[str, Any]]:
        """Get the analysis report for a URL"""
        try:
            response = requests.get(
                f"{self.base_url}/urls/{url_id}",
                headers=self.headers,
                timeout=15
            )
            
            if response.status_code == 200:
                result = response.json()
                data = result.get('data', {})
                attributes = data.get('attributes', {})
                stats = attributes.get('last_analysis_stats', {})
                
                return True, {
                    'found': True,
                    'stats': stats,
                    'url': attributes.get('url', ''),
                    'vt_link': f"https://www.virustotal.com/gui/url/{url_id}"
                }
            elif response.status_code == 404:
                return True, {'found': False}
            else:
                return False, {'error': f"Status code: {response.status_code}"}
        except requests.exceptions.RequestException as e:
            return False, {'error': str(e)}
    
    def wait_for_analysis(self, analysis_id: str, max_attempts: int = 30, delay: int = 2) -> Tuple[bool, Dict[str, Any]]:
        """Wait for analysis to complete and return results"""
        for _ in range(max_attempts):
            success, result = self.get_analysis_report(analysis_id)
            
            if not success:
                return False, result
            
            if result.get('status') == 'completed':
                return True, result
            
            time.sleep(delay)
        
        return False, {'error': 'Analysis timeout - please check results later'}
